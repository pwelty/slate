#!/usr/bin/env node

/**
 * Build-time config processor
 * Converts YAML config files to JavaScript modules
 * This eliminates runtime HTTP requests for config
 */

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import yaml from 'js-yaml'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const projectRoot = path.join(__dirname, '..')

// Paths
const configDir = path.join(projectRoot, 'config')
const outputDir = path.join(projectRoot, 'src', 'generated')

// Ensure output directory exists
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true })
}

console.log('🔧 Processing configuration files...')

try {
  // Read YAML files
  const configPath = path.join(configDir, 'config.yaml')
  const widgetsPath = path.join(configDir, 'widgets.yaml')
  
  if (!fs.existsSync(configPath)) {
    throw new Error(`Config file not found: ${configPath}`)
  }
  
  if (!fs.existsSync(widgetsPath)) {
    throw new Error(`Widgets file not found: ${widgetsPath}`)
  }
  
  const configYaml = fs.readFileSync(configPath, 'utf8')
  const widgetsYaml = fs.readFileSync(widgetsPath, 'utf8')
  
  // Parse YAML
  const config = yaml.load(configYaml)
  const widgets = yaml.load(widgetsYaml)
  
  console.log(`✓ Loaded config: ${Object.keys(config).length} settings`)
  console.log(`✓ Loaded widgets: ${Object.keys(widgets).length} widgets`)
  
  // Merge into expected structure
  const mergedConfig = {
    ...config,
    components: Object.entries(widgets).map(([id, widget]) => ({
      id,
      ...widget
    }))
  }
  
  // Validate config
  validateConfig(mergedConfig)
  
  // Generate JavaScript module
  const configJs = `// Auto-generated at build time from config/config.yaml and config/widgets.yaml
// Do not edit this file directly - edit the YAML files instead

export const dashboardConfig = ${JSON.stringify(mergedConfig, null, 2)};

export const buildInfo = {
  timestamp: ${Date.now()},
  date: "${new Date().toISOString()}",
  configFiles: [
    "config/config.yaml",
    "config/widgets.yaml"
  ]
};

// Helper function to get config sections
export const getGlobalConfig = () => {
  const { components, ...global } = dashboardConfig;
  return global;
};

export const getWidgets = () => dashboardConfig.components || [];

export const getWidgetById = (id) => {
  return dashboardConfig.components?.find(widget => widget.id === id);
};

export const getWidgetsByType = (type) => {
  return dashboardConfig.components?.filter(widget => widget.type === type) || [];
};
`
  
  // Write the generated config
  const outputPath = path.join(outputDir, 'config.js')
  fs.writeFileSync(outputPath, configJs)
  
  console.log(`✓ Generated: ${outputPath}`)
  console.log(`✓ Build timestamp: ${new Date().toISOString()}`)
  console.log('🎉 Configuration processing complete!')
  
} catch (error) {
  console.error('❌ Configuration processing failed:', error.message)
  process.exit(1)
}

function validateConfig(config) {
  const errors = []
  
  // Basic validation
  if (!config.title) {
    errors.push('Missing required field: title')
  }
  
  if (!config.components || !Array.isArray(config.components)) {
    errors.push('Missing or invalid components array')
  }
  
  // Validate components
  config.components?.forEach((component, index) => {
    if (!component.id) {
      errors.push(`Component ${index} missing required field: id`)
    }
    
    if (!component.type) {
      errors.push(`Component ${component.id || index} missing required field: type`)
    }
  })
  
  if (errors.length > 0) {
    throw new Error(`Config validation failed:\n${errors.join('\n')}`)
  }
  
  console.log('✓ Configuration validation passed')
} 